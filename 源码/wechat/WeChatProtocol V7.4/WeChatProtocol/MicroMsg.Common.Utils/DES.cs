
// Generated by .NET Reflector from D:\lu4kyd0y\Desktop\WeChatV2.3.3\WeChat\bin\Debug\MicroMsgCommon.dll
namespace WeChat.MicroMsg.Common.Utils
{
    using System;

    public class DES
    {
        public const int DECRYPTION = 2;
        private static byte[] E_TABLE = new byte[] {
            0x1f, 0, 1, 2, 3, 4, 3, 4, 5, 6, 7, 8, 7, 8, 9, 10,
            11, 12, 11, 12, 13, 14, 15, 0x10, 15, 0x10, 0x11, 0x12, 0x13, 20, 0x13, 20,
            0x15, 0x16, 0x17, 0x18, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1b, 0x1c, 0x1d, 30, 0x1f, 0
        };
        public const int ENCRYPTION = 1;
        private static int[] IP_TABLE = new int[] {
            0x39, 0x31, 0x29, 0x21, 0x19, 0x11, 9, 1, 0x3b, 0x33, 0x2b, 0x23, 0x1b, 0x13, 11, 3,
            0x3d, 0x35, 0x2d, 0x25, 0x1d, 0x15, 13, 5, 0x3f, 0x37, 0x2f, 0x27, 0x1f, 0x17, 15, 7,
            0x38, 0x30, 40, 0x20, 0x18, 0x10, 8, 0, 0x3a, 50, 0x2a, 0x22, 0x1a, 0x12, 10, 2,
            60, 0x34, 0x2c, 0x24, 0x1c, 20, 12, 4, 0x3e, 0x36, 0x2e, 0x26, 30, 0x16, 14, 6
        };
        private static int[] IPF_TABLE = new int[] {
            0x27, 7, 0x2f, 15, 0x37, 0x17, 0x3f, 0x1f, 0x26, 6, 0x2e, 14, 0x36, 0x16, 0x3e, 30,
            0x25, 5, 0x2d, 13, 0x35, 0x15, 0x3d, 0x1d, 0x24, 4, 0x2c, 12, 0x34, 20, 60, 0x1c,
            0x23, 3, 0x2b, 11, 0x33, 0x13, 0x3b, 0x1b, 0x22, 2, 0x2a, 10, 50, 0x12, 0x3a, 0x1a,
            0x21, 1, 0x29, 9, 0x31, 0x11, 0x39, 0x19, 0x20, 0, 40, 8, 0x30, 0x10, 0x38, 0x18
        };
        private static byte[] LOOP_TABLE = new byte[] { 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 };
        private static byte[] P_TABLE = new byte[] {
            15, 6, 0x13, 20, 0x1c, 11, 0x1b, 0x10, 0, 14, 0x16, 0x19, 4, 0x11, 30, 9,
            1, 7, 0x17, 13, 0x1f, 0x1a, 2, 8, 0x12, 12, 0x1d, 5, 0x15, 10, 3, 0x18
        };
        private static int[] PC1_TABLE = new int[] {
            0x38, 0x30, 40, 0x20, 0x18, 0x10, 8, 0, 0x39, 0x31, 0x29, 0x21, 0x19, 0x11, 9, 1,
            0x3a, 50, 0x2a, 0x22, 0x1a, 0x12, 10, 2, 0x3b, 0x33, 0x2b, 0x23, 0x3e, 0x36, 0x2e, 0x26,
            30, 0x16, 14, 6, 0x3d, 0x35, 0x2d, 0x25, 0x1d, 0x15, 13, 5, 60, 0x34, 0x2c, 0x24,
            0x1c, 20, 12, 4, 0x1b, 0x13, 11, 3
        };
        private static byte[] PC2_TABLE = new byte[] {
            13, 0x10, 10, 0x17, 0, 4, 2, 0x1b, 14, 5, 20, 9, 0x16, 0x12, 11, 3,
            0x19, 7, 15, 6, 0x1a, 0x13, 12, 1, 40, 0x33, 30, 0x24, 0x2e, 0x36, 0x1d, 0x27,
            50, 0x2c, 0x20, 0x2f, 0x2b, 0x30, 0x26, 0x37, 0x21, 0x34, 0x2d, 0x29, 0x31, 0x23, 0x1c, 0x1f
        };
        private static byte[] S_BOX = new byte[] {
            14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7,
            0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8,
            4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0,
            15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13,
            15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10,
            3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5,
            0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15,
            13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9,
            10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8,
            13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1,
            13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7,
            1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12,
            7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15,
            13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9,
            10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4,
            3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14,
            2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9,
            14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6,
            4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14,
            11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3,
            12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11,
            10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8,
            9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6,
            4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13,
            4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1,
            13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6,
            1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2,
            6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12,
            13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7,
            1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2,
            7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8,
            2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11
        };

        private static void BitToByte(byte[] Out, int OutOffset, byte[] In, int bits)
        {
            Array.Clear(Out, OutOffset, bits >> 3);
            for (int i = 0; i < bits; i++)
            {
                Out[(i >> 3) + OutOffset] |= (byte)(In[i] << (i & 7));
            }
        }

        private static void ByteToBit(byte[] Out, int OutOffset, byte[] In, int InOffset, int bits)
        {
            for (int i = 0; i < bits; i++)
            {
                int index = (i >> 3) + InOffset;
                Out[i + OutOffset] = (byte)((In[index] >> (i & 7)) & 1);
            }
        }

        private static void CYCLELEFT(byte[] In, int InOffset, byte[] T, int len, int loop)
        {
            Array.Copy(In, InOffset, T, 0, loop);
            Array.Copy(In, InOffset + loop, In, InOffset, len - loop);
            Array.Copy(T, 0, In, (InOffset + len) - loop, loop);
        }

        private static void DES_(byte[] Out, int OutOffset, byte[] In, int InOffset, byte[] pskey, int Type, byte[] M, byte[] MR, byte[] tmp, int Li, int Ri, byte[] T)
        {
            byte[] ki = new byte[0x30];
            ByteToBit(M, 0, In, InOffset, 0x40);
            TRANSFORM_KEY(M, 0, M, 0, IP_TABLE, 0x40, T);
            if (Type == 1)
            {
                for (int i = 0; i < 0x10; i++)
                {
                    Array.Copy(M, Ri, tmp, 0, 0x20);
                    Array.Copy(pskey, i * 0x30, ki, 0, 0x30);
                    F_FUNCTION(M, Ri, ki, MR, T);
                    XOR(M, Ri, M, Li, 0x20);
                    Array.Copy(tmp, 0, M, Li, 0x20);
                }
            }
            else
            {
                for (int j = 15; j >= 0; j--)
                {
                    Array.Copy(M, Li, tmp, 0, 0x20);
                    Array.Copy(pskey, j * 0x30, ki, 0, 0x30);
                    F_FUNCTION(M, Li, ki, MR, T);
                    XOR(M, Li, M, Ri, 0x20);
                    Array.Copy(tmp, 0, M, Ri, 0x20);
                }
            }
            TRANSFORM_KEY(M, 0, M, 0, IPF_TABLE, 0x40, T);
            BitToByte(Out, OutOffset, M, 0x40);
        }

        public static byte[] EncryptBytes(byte[] destBytes, byte[] key, int type)
        {
            int outLen = destBytes.Length + 0x20;
            byte[] @out = new byte[outLen];
            if (Using_DES(@out, ref outLen, destBytes, destBytes.Length, key, key.Length, 1) == 0)
            {
                return null;
            }
            byte[] buffer2 = new byte[outLen];
            Array.Copy(@out, buffer2, buffer2.Length);
            return buffer2;
        }

        private static void F_FUNCTION(byte[] In, int InOffset, byte[] Ki, byte[] MR, byte[] T)
        {
            TRANSFORM(MR, 0, In, InOffset, E_TABLE, 0x30, T);
            XOR(MR, 0, Ki, 0, 0x30);
            S_BOXF(In, InOffset, MR);
            TRANSFORM(In, InOffset, In, InOffset, P_TABLE, 0x20, T);
        }

        private static void S_BOXF(byte[] Out, int OutOffset, byte[] In)
        {
            int index = 0;
            byte[] @in = new byte[0x10];
            int num4 = 0;
            while (num4 < 8)
            {
                int num = (In[index] << 1) + In[5 + index];
                int inOffset = (((In[1 + index] << 3) + (In[2 + index] << 2)) + (In[3 + index] << 1)) + In[4 + index];
                Array.Copy(S_BOX, (num4 * 0x40) + (num * 0x10), @in, 0, 0x10);
                ByteToBit(Out, OutOffset, @in, inOffset, 4);
                num4++;
                index += 6;
                OutOffset += 4;
            }
        }

        private static void Set_SubKey(byte[] pskey, byte[] Key, byte[] K, int KL, int KR, byte[] T)
        {
            ByteToBit(K, 0, Key, 0, 0x40);
            TRANSFORM_KEY(K, 0, K, 0, PC1_TABLE, 0x38, T);
            for (int i = 0; i < 0x10; i++)
            {
                CYCLELEFT(K, KL, T, 0x1c, LOOP_TABLE[i]);
                CYCLELEFT(K, KR, T, 0x1c, LOOP_TABLE[i]);
                TRANSFORM(pskey, i * 0x30, K, 0, PC2_TABLE, 0x30, T);
            }
        }

        private static void SETKEY(byte[] SubKey, byte[] deskey, byte[] Key, int len, byte[] K, int KL, int KR, byte[] T)
        {
            Array.Clear(deskey, 0, 0x18);
            int num = (len > 0x18) ? 0x18 : len;
            Array.Copy(Key, 0, deskey, 0, num);
            Set_SubKey(SubKey, deskey, K, KL, KR, T);
        }

        private static void TRANSFORM(byte[] Out, int OutOffset, byte[] In, int InOffset, byte[] Table, int len, byte[] T)
        {
            for (int i = 0; i < len; i++)
            {
                T[i] = In[InOffset + Table[i]];
            }
            Array.Copy(T, 0, Out, OutOffset, len);
        }

        private static void TRANSFORM_KEY(byte[] Out, int OutOffset, byte[] In, int InOffset, int[] Table, int len, byte[] T)
        {
            for (int i = 0; i < len; i++)
            {
                T[i] = In[Table[i]];
            }
            Array.Copy(T, 0, Out, OutOffset, len);
        }

        public static int Using_DES(byte[] Out, ref int OutLen, byte[] In, int InLen, byte[] Key, int keylen, int Type)
        {
            byte[] subKey = new byte[0x300];
            byte[] t = new byte[0x100];
            byte[] deskey = new byte[0x18];
            byte[] k = new byte[0x40];
            int kL = 0;
            int kR = 0x1c;
            byte[] mR = new byte[0x30];
            byte[] m = new byte[0x40];
            byte[] tmp = new byte[0x20];
            int li = 0;
            int ri = 0x20;
            byte[] @in = new byte[9];
            byte[] @out = new byte[8];
            int outOffset = 0;
            int inOffset = 0;
            byte[] buffer10 = new byte[8];
            if (((Out.GetLength(0) == 0) || (In.GetLength(0) == 0)) || ((Key.GetLength(0) == 0) || (InLen <= 0)))
            {
                return 0;
            }
            if (Out.GetLength(0) < (InLen + 0x20))
            {
                throw new ArithmeticException("Data buffer length is not enough!");
            }
            SETKEY(subKey, deskey, Key, keylen, k, kL, kR, t);
            if (Type == 1)
            {
                int num7 = 8 - (InLen % 8);
                int num8 = InLen + num7;
                byte[] buffer11 = new byte[num8];
                Array.Copy(In, 0, buffer11, 0, InLen);
                for (int i = 0; i < num7; i++)
                {
                    buffer11[InLen + i] = (byte)num7;
                }
                DES_(Out, outOffset, @in, 0, subKey, Type, m, mR, tmp, li, ri, t);
                Array.Copy(Out, outOffset, @out, 0, 8);
                outOffset += 8;
                int num10 = 0;
                int num11 = num8 >> 3;
                while (num10 < num11)
                {
                    Array.Copy(buffer11, inOffset, buffer10, 0, 8);
                    XOR2(@out, 0, @out, buffer10);
                    DES_(Out, outOffset, @out, 0, subKey, Type, m, mR, tmp, li, ri, t);
                    Array.Copy(Out, outOffset, @out, 0, 8);
                    num10++;
                    outOffset += 8;
                    inOffset += 8;
                }
                OutLen = num8 + 8;
            }
            else
            {
                Array.Copy(In, inOffset, @in, 0, 8);
                inOffset += 8;
                int num12 = 1;
                int num13 = InLen >> 3;
                while (num12 < num13)
                {
                    DES_(@out, 0, In, inOffset, subKey, Type, m, mR, tmp, li, ri, t);
                    XOR2(Out, outOffset, @out, @in);
                    Array.Copy(In, inOffset, @in, 0, 8);
                    num12++;
                    outOffset += 8;
                    inOffset += 8;
                }
                int num14 = Out[(inOffset - 8) - 1];
                int num15 = inOffset - 8;
                for (int j = 0; j < num14; j++)
                {
                    Out[(num15 - j) - 1] = 0;
                }
                OutLen = num15 - num14;
            }
            return 1;
        }

        private static void XOR(byte[] InA, int AOffset, byte[] InB, int BOffset, int len)
        {
            for (int i = 0; i < len; i++)
            {
                InA[i + AOffset] ^= InB[i + BOffset];
            }
        }

        private static void XOR2(byte[] Out, int OutOffset, byte[] In1, byte[] In2)
        {
            for (int i = 0; i < 8; i++)
            {
                Out[i + OutOffset] = (byte)(In1[i] ^ In2[i]);
            }
        }
    }
}
